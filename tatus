[1mdiff --git a/src/main/java/de/katzenpapst/amunra/block/ore/SubBlockOre.java b/src/main/java/de/katzenpapst/amunra/block/ore/SubBlockOre.java[m
[1mindex 354bed6..aabc0fb 100755[m
[1m--- a/src/main/java/de/katzenpapst/amunra/block/ore/SubBlockOre.java[m
[1m+++ b/src/main/java/de/katzenpapst/amunra/block/ore/SubBlockOre.java[m
[36m@@ -1,87 +1,83 @@[m
 package de.katzenpapst.amunra.block.ore;[m
 [m
[31m-import java.util.Random;[m
[31m-[m
 import net.minecraft.item.Item;[m
 import net.minecraft.item.ItemStack;[m
[31m-import net.minecraft.util.MathHelper;[m
[31m-import net.minecraft.world.IBlockAccess;[m
[31m-import de.katzenpapst.amunra.block.SubBlock;[m
[31m-import de.katzenpapst.amunra.item.ItemDamagePair;[m
[32m+[m[32mimport de.katzenpapst.amunra.block.SubBlockDropItem;[m
 [m
[31m-public class SubBlockOre extends SubBlock {[m
[32m+[m[32mpublic class SubBlockOre extends SubBlockDropItem {[m
 [m
[31m-	/**[m
[31m-	 * The IDP containing what to drop[m
[31m-	 */[m
[31m-	protected ItemDamagePair droppedItems = null;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * The IDP containing what to drop[m
[32m+[m[32m     */[m
[32m+[m[32m    //protected ItemDamagePair droppedItems = null;[m
 [m
[31m-	protected String[] oredictNames = {};[m
[32m+[m[32m    protected String[] oredictNames = {};[m
 [m
[31m-	protected ItemStack smeltItem = null;[m
[32m+[m[32m    protected ItemStack smeltItem = null;[m
 [m
[31m-	/**[m
[31m-	 * Minimum amount to drop. Probably shouldn't be != 1...[m
[31m-	 */[m
[31m-	protected int baseDropRateMin = 1;[m
[31m-	/**[m
[31m-	 * Usually fortune 3 can give up to 4 items. This will be multiplied on that value[m
[31m-	 */[m
[31m-	protected float bonusDropMultiplier = 1;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Minimum amount to drop. Probably shouldn't be != 1...[m
[32m+[m[32m     */[m
[32m+[m[32m    //protected int baseDropRateMin = 1;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Usually fortune 3 can give up to 4 items. This will be multiplied on that value[m
[32m+[m[32m     */[m
[32m+[m[32m    //protected float bonusDropMultiplier = 1;[m
 [m
[31m-	protected int xpDropMin = 0;[m
[31m-	protected int xpDropMax = 0;[m
[32m+[m[32m    //protected int xpDropMin = 0;[m
[32m+[m[32m    //protected int xpDropMax = 0;[m
 [m
[31m-	//for xp drop[m
[31m-	protected Random rand = new Random();[m
[32m+[m[32m    //for xp drop[m
[32m+[m[32m    //protected Random rand = new Random();[m
 [m
[31m-	public SubBlockOre setOredictNames(String... newNames) {[m
[31m-		this.oredictNames = newNames;[m
[31m-		return this;[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre setOredictNames(String... newNames) {[m
[32m+[m[32m        this.oredictNames = newNames;[m
[32m+[m[32m        return this;[m
[32m+[m[32m    }[m
 [m
[31m-	public String[] getOredictNames() {[m
[31m-		return this.oredictNames;[m
[31m-	}[m
[32m+[m[32m    public String[] getOredictNames() {[m
[32m+[m[32m        return this.oredictNames;[m
[32m+[m[32m    }[m
 [m
[31m-	public ItemStack getSmeltItem() {[m
[31m-		return smeltItem;[m
[31m-	}[m
[32m+[m[32m    public ItemStack getSmeltItem() {[m
[32m+[m[32m        return smeltItem;[m
[32m+[m[32m    }[m
 [m
[31m-	public SubBlockOre setSmeltItem(Item item, int num, int metadata) {[m
[31m-		smeltItem = new ItemStack(item, num, metadata);[m
[31m-		return this;[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre setSmeltItem(Item item, int num, int metadata) {[m
[32m+[m[32m        smeltItem = new ItemStack(item, num, metadata);[m
[32m+[m[32m        return this;[m
[32m+[m[32m    }[m
 [m
[31m-	public SubBlockOre setSmeltItem(Item item, int num) {[m
[31m-		smeltItem = new ItemStack(item, num, 0);[m
[31m-		return this;[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre setSmeltItem(Item item, int num) {[m
[32m+[m[32m        smeltItem = new ItemStack(item, num, 0);[m
[32m+[m[32m        return this;[m
[32m+[m[32m    }[m
 [m
[31m-	public SubBlockOre setSmeltItem(ItemStack stack) {[m
[31m-		smeltItem = stack;[m
[31m-		return this;[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre setSmeltItem(ItemStack stack) {[m
[32m+[m[32m        smeltItem = stack;[m
[32m+[m[32m        return this;[m
[32m+[m[32m    }[m
 [m
 [m
[31m-	public SubBlockOre(String name, String texture) {[m
[31m-		super(name, texture);[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre(String name, String texture) {[m
[32m+[m[32m        super(name, texture);[m
[32m+[m[32m    }[m
 [m
[31m-	public SubBlockOre(String name, String texture, String tool,[m
[31m-			int harvestLevel) {[m
[31m-		super(name, texture, tool, harvestLevel);[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre(String name, String texture, String tool,[m
[32m+[m[32m            int harvestLevel) {[m
[32m+[m[32m        super(name, texture, tool, harvestLevel);[m
[32m+[m[32m    }[m
 [m
[31m-	public SubBlockOre(String name, String texture, String tool,[m
[31m-			int harvestLevel, float hardness, float resistance) {[m
[31m-		super(name, texture, tool, harvestLevel, hardness, resistance);[m
[31m-	}[m
[32m+[m[32m    public SubBlockOre(String name, String texture, String tool,[m
[32m+[m[32m            int harvestLevel, float hardness, float resistance) {[m
[32m+[m[32m        super(name, texture, tool, harvestLevel, hardness, resistance);[m
[32m+[m[32m    }[m
 [m
[31m-	@Override[m
[31m-	public int quantityDropped(int meta, int fortune, Random random)[m
[31m-	{[m
[31m-		int j = random.nextInt(fortune + 2) - 1;[m
[32m+[m[32m    /*[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public int quantityDropped(int meta, int fortune, Random random)[m
[32m+[m[32m    {[m
[32m+[m[32m        int j = random.nextInt(fortune + 2) - 1;[m
 [m
         if (j < 0) {[m
             j = 0;[m
[36m@@ -89,18 +85,19 @@[m [mpublic class SubBlockOre extends SubBlock {[m
 [m
         int result = (int) (this.quantityDropped(random) * (j + 1) * bonusDropMultiplier);[m
         if(result < baseDropRateMin) {[m
[31m-        	result = baseDropRateMin;[m
[32m+[m[32m            result = baseDropRateMin;[m
         }[m
         return result;[m
 [m
[31m-		//return Math.min(random.nextInt(3)+random.nextInt(10)*fortune, 9);[m
[31m-	}[m
[31m-	/**[m
[32m+[m[32m        //return Math.min(random.nextInt(3)+random.nextInt(10)*fortune, 9);[m
[32m+[m[32m    }[m
[32m+[m[32m    * /[m
[32m+[m[32m    / **[m
      * Returns the quantity of items to drop on block destruction.[m
      * There is no metadata here, so if this stuff is called from the outside, I can't do shit[m
[31m-     */[m
[32m+[m[32m     * /[m
     @Override[m
[31m-	public int quantityDropped(Random rand)[m
[32m+[m[32m    public int quantityDropped(Random rand)[m
     {[m
         return baseDropRateMin;[m
     }[m
[36m@@ -108,59 +105,65 @@[m [mpublic class SubBlockOre extends SubBlock {[m
     @Override[m
     public int damageDropped(int meta)[m
     {[m
[31m-		return droppedItems.getDamage();[m
[32m+[m[32m        return droppedItems.getDamage();[m
     }[m
 [m
     @Override[m
[31m-	public Item getItemDropped(int meta, Random random, int fortune)[m
[32m+[m[32m    public Item getItemDropped(int meta, Random random, int fortune)[m
     {[m
[31m-		return droppedItems.getItem();[m
[32m+[m[32m        return droppedItems.getItem();[m
     }[m
 [m
[32m+[m[32m    @Override[m
     public SubBlockOre setDroppedItem(ItemDamagePair item) {[m
[31m-    	droppedItems = item;[m
[31m-    	return this;[m
[32m+[m[32m        droppedItems = item;[m
[32m+[m[32m        return this;[m
     }[m
 [m
[32m+[m[32m    @Override[m
     public SubBlockOre setDroppedItem(Item item) {[m
[31m-    	droppedItems = new ItemDamagePair(item, 0);[m
[31m-    	return this;[m
[32m+[m[32m        droppedItems = new ItemDamagePair(item, 0);[m
[32m+[m[32m        return this;[m
     }[m
 [m
[32m+[m[32m    @Override[m
     public SubBlockOre setMinDropRate(int val) {[m
[31m-    	baseDropRateMin = val;[m
[31m-    	return this;[m
[32m+[m[32m        baseDropRateMin = val;[m
[32m+[m[32m        return this;[m
     }[m
 [m
[32m+[m[32m    @Override[m
     public SubBlockOre setBonusMultiplier(float val) {[m
[31m-    	bonusDropMultiplier = val;[m
[31m-    	return this;[m
[32m+[m[32m        bonusDropMultiplier = val;[m
[32m+[m[32m        return this;[m
     }[m
 [m
[32m+[m[32m    @Override[m
     public SubBlockOre setXpDrop(int dropMin, int dropMax) {[m
[31m-    	xpDropMin = dropMin;[m
[31m-    	xpDropMax = dropMax;[m
[31m-    	return this;[m
[32m+[m[32m        xpDropMin = dropMin;[m
[32m+[m[32m        xpDropMax = dropMax;[m
[32m+[m[32m        return this;[m
     }[m
 [m
     @Override[m
[31m-	public boolean dropsSelf() {[m
[31m-		return droppedItems == null;[m
[31m-	}[m
[32m+[m[32m    public boolean dropsSelf() {[m
[32m+[m[32m        return droppedItems == null;[m
[32m+[m[32m    }[m
 [m
     @Override[m
[31m-	public int getExpDrop(IBlockAccess world, int metadata, int fortune) {[m
[31m-    	if(!dropsSelf()) {[m
[31m-    		if(xpDropMin <= xpDropMax) {[m
[31m-    			return xpDropMin;[m
[31m-    		}[m
[31m-    		MathHelper.getRandomIntegerInRange(rand, xpDropMin, xpDropMax);[m
[31m-    	}[m
[31m-    	return 0;[m
[32m+[m[32m    public int getExpDrop(IBlockAccess world, int metadata, int fortune) {[m
[32m+[m[32m        if(!dropsSelf()) {[m
[32m+[m[32m            if(xpDropMin <= xpDropMax) {[m
[32m+[m[32m                return xpDropMin;[m
[32m+[m[32m            }[m
[32m+[m[32m            MathHelper.getRandomIntegerInRange(rand, xpDropMin, xpDropMax);[m
[32m+[m[32m        }[m
[32m+[m[32m        return 0;[m
     }[m
 [m
     @Override[m
[31m-	public boolean isValueable(int metadata) {[m
[31m-		return true;[m
[31m-	}[m
[32m+[m[32m    public boolean isValueable(int metadata) {[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    */[m
 }[m
